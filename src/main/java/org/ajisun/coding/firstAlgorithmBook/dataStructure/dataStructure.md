### 一， 链表
> 查询的时间复杂度O(n),添加删除时间复杂度O(1)

   * 链表 删除/新增较快，查询较慢(需要从头节点顺着指针一一往下访问开始查找)
   * 链表的存储不是空间连续的，每个数据块都包含一个指针，指向下一个数据的内存地址
   * 如果添加/删除数据只需要改变指针的指向即可

```
   尾部指针指向头部-----环形链表
   两个指针指向前后数据-----双向链表
```




### 二，数组
> 查询的时间复杂度O(1),添加删除时间复杂度O(n)


 * 数组 查询较快(通过下标计算出内存地址)，删除和增加较慢(需要移动后面的数据)
 * 数组的存储空间是连续的



### 三，栈(LIFO)
> 只能访问最新的数据(后进先出，Last In First Out)

 * 入栈(push)-----栈中添加数据是放在最上面
 * 出栈(pop) -----栈中弹出最上面的数据
 * 添加和删除的动作只能在一端进行
 
 ```text
比如，规定（AB（C（DE）F）（G（（H）I J）K））这一串字符中括号的处理方式如下：
首先从左边开始读取字符，读到左括号就将其入栈，读到右括号就将栈顶的左括号出栈。此时，出栈的左括号便与当前读取的右括号相匹配。
通过这种处理方式，我们就能得知配对括号的具体位置。
```


### 四，队列
> 前出后进(先进先出，First In First Out)

 * 入队：往队列中添加数据(队尾)
 * 出队：从队列中删除数据(队头，最早入队的数据)
 * 操作数据必须让目标数据变成首位
 
 
### 五，哈希表
> 计算key的hash值，然后进行mod运算，获取到具体位置
 
 * key-value格式存储
 * 获取key的哈希值a，然后根据数组大小n计算mod值就是存放的下标 
 * 如果不同的key mod的结果一直，就是出现哈希冲突
 * 出现冲突可以使用链表在后面继续存储， 方法成为 `链地址法` 
 * 还有常用方法 `开放地址法`，通过多次使用哈希函数获取下一个为空的候补地址
 
 

### 六，堆
> 一种图的树形结构

 * 堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都
   为 O(1)。
 * 堆中的每个结点最多有两个子结点
 * 子结点必定大于父结点


### 七，二叉查找树


 * 每个结点最多有两个子节点
 * 是每个结点的值均大于其左子树上任意一个结点的值
 * 每个结点的值均小于其右子树上任意一个结点的值
 
 
 ```text
二叉查找树的最小结点要从顶端开始，往其左下的末端寻找
二叉查找树的最大结点要从顶端开始，往其右下的末端寻找
```